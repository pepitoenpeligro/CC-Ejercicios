# Ejercicio 1. Instalar alguno de los entornos virtuales de `node.js` (o de cualquier otro lenguaje con el que se esté familiarizado) y, con ellos, instalar la última versión existente, la versión `minor` más actual de la 4.x y lo mismo para la 0.11 o alguna impar (de desarrollo).

Comenzamos instalando `nodeenv` como entorno virtual, aunque podríamos haber instalado cualquier otro como:
* nave
* nvm
* n

La instalación como usuario de `nodeenv` hemos ejecutado:

```
pip3 install nodeenev
```


Posteriormente creamos un entorno con el comando:

```
nodeenv mientorno
```

Se adjunta una imagen que justifica y muestra los pasos anteriores


![Instalación de Nodeenv](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/01-nodeenv-installed.png)

Podemos realizar un listado de todas las versiones de nodejs disponibles con:

```
nodeenv --list
```

![Lista de entornos disponibles](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/01-nodeenv-list.png)


Para instalar versiones concretas de un entorno virtual nos basta con indicárselo con --node y un nombre de entorno que queramos:

```
nodeenv --node=X.X.X NOMBRE
ls
```

Por tanto, realizamos la instalación de la versión 4.9.1, que es la versión __minor__ más actual y la 11.1.0 que es la versión impar más reciente.

```
nodeenv --node=4.9.1 entorno-4.9.1
nodeenv --node=11.1.0 entorno-11.1.0
```

![Instalación de dos entornos virtuales concretos](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/01-nodeenv-env-install.png)


# Ejercicio 2. Crear una descripción del módulo usando `package.json`. En caso de que se trate de otro lenguaje, usar el método correspondiente.  

Para crear una descripción del módulo, es necesario crear un archivo de descripción de módulo. Esta acción puede llevarse a cabo con cualquier gestor de paquetes como:

* npm
* bower
* yarn
* gulp
* nuget
* maven

En nuestro caso, vamos a usar npm ya que lo usé en mi tfg y es ampliamente usado, además, en sus ultimas versiones tiene el detalle de enlazar y recordar el apoyo a ciertos paquetes.

Para inicializar una descripción de módulo es tan simple como ejecutar:

```
npm init
```

Para completar un poco más, si hubiéramos usado `bower` sería similar:

```
bower init
```


Podemos ver que ha creado un fichero `package.json` en la raíz de nuestro directorio y 


![Instalación de dos entornos virtuales concretos](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/02-npm-init.png)


Para incluir una dependencia, simplemente debemos ejecutar:

```
npm install <package>@<version>
```

Por ejemplo

```
npm install express@4.0.0
```





# Ejercicio 3. Descargar el repositorio de ejemplo anterior, instalar las herramientas necesarias (principalmente Scala y sbt) y ejecutar el ejemplo desde `sbt`. Alternativamente, buscar otros marcos para REST en Scala tales como Finatra o Scalatra y probar los ejemplos que se incluyan en el repositorio. 

Para poder usar `scala` y `sbt` debemos tener instalado el *Java Developer Kit*, en concreto, debemos tener instalado la versión 1.8 del jdk.

:warning: **JDK**: Si tienes alguna otra versión de jdk ya instalada, puedes consultar todas tus versiones con:

```
/usr/libexec/java_home -V
```

:warning: **JDK**: Puedes cambiar de forma temporal tu version de java por defecto a la 1.8 con el siguiente comando:

```
export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)
```


Para un sistema Os X con el gestor de paquetes brew instalado, esto se puede hacer como sigue:

```
brew tap adoptopenjdk/openjdk
brew cask install adoptopenjdk11
```

Una vez instalado el jdk, podemos instalar scala y sbt con:

```
brew install scala@2.11
brew install sbt
brew link scala@2.11 --force
```

:warning: **Scala**: Asegurate de que instalas la versión 2.11 o la que se te indique en el repo original!

![Instalando Scala](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-scala-installing.png)

![Instalando SBT](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-sbt-installing.png)



Estamos en condiciones para hacer el clonado del repositorio:

```
git clone https://github.com/JJ/spray-test.git

o

gh repo clone JJ/spray-test
```

![Clonando el repositorio](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-clone.png)

Ahora podemos compilar el proyecto usando sbt:



```
sbt compile
> test
```


![Compilando el proyecto y ejecutando los test](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-sbt-compile-test.png)


Es hora de relanzar el servicio y realizar las peticiones get y put correspondientes:

```
>re-start
```


![Reiniciando el proyecto](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-sbt-restart.png)


```
curl http://localhost:8080
curl -X PUT http://localhost:8080/0/0/Uno 
curl -X PUT http://localhost:8080/0/1/Otro                                                                            
curl -X PUT http://localhost:8080/3/1/Aquel
curl http://localhost:8080/Aquel     
```

![Realizando las peticiones al servidor](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-rest-requests.png)

Y por último paramos el servicio con

```
>re-stop
>exit
```


![Parando el servicio](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/2/03-stop-service.png)



# Ejercicio 4. Para la aplicación que se está haciendo, escribir una serie de aserciones y probar que efectivamente no fallan. Añadir tests para una nueva funcionalidad, probar que falla y escribir el código para que no lo haga. A continuación, ejecutarlos desde *mocha* (u otro módulo de test de alto nivel), usando descripciones del test y del grupo de test de forma correcta. Si hasta ahora no has subido el código que has venido realizando a GitHub, es el momento de hacerlo, porque lo vamos a necesitar un poco más adelante. 



# Ejercicio 5. Haced los dos primeros pasos antes de pasar al tercero.