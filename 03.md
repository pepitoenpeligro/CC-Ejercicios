# Ejercicio 1. Buscar alguna demo interesante de Docker y ejecutarla localmente, o en su defecto, ejecutar la imagen anterior y ver cómo funciona y los procesos que se llevan a cabo la primera vez que se ejecuta y las siguientes ocasiones. 

Necesitamos primero instalar `Docker`. Para instalar `Docker` en `OS X` vamos a usar el gestor de paquetes `brew` tal y como hemos venido haciendo en los ejercicios del tema 1 y tema 2.


```shell
brew install docker docker-machine
brew cask install virtualbox
```

![Docker Version](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/01-docker-version.png)

Vamos a configurar `docker-machine`, que es una herramienta que nos permite crear, gestionar y configurar máquinas virtuales o físicas con `Docker Engine`. Nos será útil más adelante. Para ello le indicamos que el _driver_ principal es `virtualbox`:


```shell
docker-machine create --driver virtualbox default
docker-machine ls
docker-machine env default
```

![Docker Machine Setup](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/01-docker-version.png)

:warning: Podemos reiniciar la máquina docker con `docker-machine restart`


![Docker Hello World](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/01-docker-hello-world.png)

Encontramos una imagen docker interesante en `jjmerelo/dalesky` que podemos encontrar en [Docker Hub](https://hub.docker.com/r/jjmerelo/docker-daleksay)

```shell
docker pull jjmerelo/docker-daleksay
docker run -rm jjmerelo/docker-daleksay
```

:warning: En caso de no tener una imagen de docker, si corremos `docker run --rm <imagen>`, se encargará de descargar la imagen y ejecutarla en cuanto la tenga disponible.

![Docker jjmerelo dalesky](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/01-docker-jjmerelo-dalesky.png)






# Ejercicio 2. Tomar algún programa simple, "Hola mundo" impreso desde el intérprete de línea de órdenes, y comparar el tamaño de las imágenes de diferentes sistemas operativos base, Fedora, CentOS y Alpine, por ejemplo.


Vamos a generar el `Dockerfile` para crear la imagen con _Fedora_:

```shell
FROM fedora:latest

# Establecemos el directorio de trabajo del ejercicio.
WORKDIR /Users/pp/Google\ Drive/mii/1/CC/pruebas/4

RUN dnf install perl -y

# Copiamos el script hipepe a la raiz del contenedor
COPY ./hipepe.pl ./

# El comando a ejecutar es perl junto al script
CMD ["perl", "./hipepe.pl"]
```


```shell
docker build --no-cache -t fedoraperl -f Dockerfile .
```

Y lanzamos el contenedor para que nos salude.

![Docker Fedoraperl](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/02-fedora-perl.png)



Ahora vamos a generar el `Dockerfile` para _centos_, en concreto usando la versión 8 de _centos_.

```shell
FROM centos:centos8

# Establecemos el directorio de trabajo del ejercicio.
WORKDIR /Users/pp/Google\ Drive/mii/1/CC/pruebas/4

RUN yum install perl -y


# Copiamos el script hipepe a la raiz del contenedor
COPY ./hipepe.pl ./

# El comando a ejecutar es perl junto al script
CMD ["perl", "./hipepe.pl"]
```

Y lanzamos el contenedor para que nos salude.

```shell
docker build --no-cache -t centosperl -f Dockerfile .
```

![Docker Centosperl](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/02-centos-perl.png)

Ahora vamos a generar el `Dockerfile` para _alpine_, en concreto usando la última versión estable de _alpine_.


```shell
FROM alpine:latest

# Establecemos el directorio de trabajo del ejercicio.
WORKDIR /Users/pp/Google\ Drive/mii/1/CC/pruebas/4

RUN apk update && apk add perl


# Copiamos el script hipepe a la raiz del contenedor
COPY ./hipepe.pl ./

# El comando a ejecutar es perl junto al script
CMD ["perl", "./hipepe.pl"]
```

Y lanzamos el contenedor para que nos salude.

```shell
docker build --no-cache -t alpineperl -f Dockerfile .
```

![Docker Alpineperl](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/02-alpine-perl.png)


Ahora vamos a comprobar el peso de cada una de las imágenes ejecutando:

```shell
docker images 
```

![Docker images](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/02-docker-images.png)

Podemos observar como la imagen que menos peso tiene es la de __alpine__. Esto se debe principalmente a que el sistema contiene lo básico y necesario para ejecutarse y que pesa entre 4-6 MB, mientras que _fedora_ o _centos_, pesan varios MB más.



# Ejercicio 3. Crear a partir del contenedor anterior una imagen persistente con `commit`.

Primero comenzamos observando los contenedores y sus estados con:

```shell
docker ps -l
```

Y vemos que existe un contenedor con una imagen llamada __alpineperl__ que es justo la última que ejecutamos en el ejercicio anterior (ver ejercicio 2). 

Si nos fijamos, nos indica un `container id`. Ese identificador único, es el que nos sirve para crear la nueva imagen a partir de dicho contenedor.


```shell
docker commit <containerID> <nameNewContainer>
```

Ahora podemos visualizar si efectivamente fue creado con:

```shell
docker image ls
```

Y efectivamente fue creado, pesa exactamente lo mismo que el original (no hubo cambios) y su nombre es justo el indicado.

![Docker commit](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/03-docker-commit.png)







# Ejercicio 4. Examinar la estructura de capas que se forma al crear imágenes nuevas a partir de contenedores que se hayan estado ejecutando.

Docker funciona gracias a la arquitectura de capas. Existen diversas capas, y el archivo `Dockerfile` es el `trigger` para crear capas. Por ejemplo, tal y como vimos en el ejercicio anterior (ver ejercicio 3), cuando usamos __COPY__ estamos generando una capa síncrona para poder hacer posible el intercambio de ficheros desde mi máquina local hasta la imagen. También generamos otra capa __RUN__, que nos sirve para ejecutar programas y comandos del SO de la imagen seleccionada. También ocurre con __WORKDIRECTORY__ o __ENTRYPOINT__, ambas crear nuevas capas. Vamos a tratar de ver esto con la ayuda de la consola de comandos.

En mi caso voy a exponerlo desde OS X que es el sistema que uso, pero si usamos una distribución linux, nos basta con:

```shell
cd /var/lib/docker/aufs/layers/<ContainerID>
```

Para OS X vamos a usar la herramienta `dive` que es muy completa, escrita en Go, y nos da información en tiempo real. 
:warning: También podemos instalar `dive` en cualquier distro linux.


```shell
brew tap wagoodman/dive
brew install dive
```

Y ejecutamos:

```shell
dive alpineperl
dive fedoraperl
```

Y podemos observar las capas y sus tamaños, la estructura de directorios de la image y permisos.

:warning: Mirar la estructura de capas en alpine no tarda lo mismo que en fedora. Esto es debido al tamaño de la imagen.

![Dive alpineperl](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/04-dive-alpineperl.png)
![Dive fedoraperl](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/04-dive-fedoraperl.png)



# Ejercicio 5. Crear un volumen y usarlo, por ejemplo, para escribir la salida de un programa determinado.

Para comenzar, tenemos que comprender bien qué es un volumen en el contexto de `Docker`.

Un volumen es un sistema de archivos montado en el contenedor para preservar los ficheros que genere el contenedor en ejecución, por lo que dicho volumen, realmente se almacenará en el espacio del sistema hospedador (host).

Para crear un nuevo volumen nos basta con:

```shell
docker volume create <nombreDelVolumen>
```

Y a partir de ahí podemos examinar los volúmenes existentes con:

```shell
docker volume list
```

Y podemos averiguar más información como la fecha de creación, o el punto de montaje real con:

```shell
docker inspect <nombreDelVoluem>
```

![Docker Volume Create](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/05-docker-volume-create.png)


Si queremos hacer uso del volumen, tendremos que montar el volumen en la imagen que deseemos, para ello nos basta con indicárselo como indicamos a continuación:

```
docker run --mount source=<nombreDelVolumen>,destination=<rutaAMontarEnElContenedor> <imagenDocker>
docker run --mount source=unGranVolumen,destination=/volumenGrandeFuera alpineperl
```

Vamos a crear un nuevo contenedor con una nueva versión del script de perl para que escriba en un archivo la salida, pero primero modificamos nuestro programa `hipepe.pl`

```
#!/usr/bin/perl
use warnings;
use strict;

my $aEscribir = <<END;
Hola Pepe
Te saludo desde mi fichero
END

my $nombreArchivo = '/volumenGrandeFuera/salida.txt';
print("A continuacion te escribo en el fichero del volumen docker /unGranVolumen pero que yo veo como /volumenGrandeFuera:\n");
print($aEscribir);
open (ESCRITURA, '>', $nombreArchivo) or die "[escritura] no pude abrir el fichero";
print ESCRITURA $aEscribir;
close(ESCRITURA);

print("Fin de la escritura\n\n");

print("A continuacion te muestro lo que he leido del fichero del volumen docker anteriormente escrito:\n");
open (LECTURA, '<', $nombreArchivo) or die "[lectura] no pude abrir el fichero";
while(<LECTURA>){
    print $_;
}
close(LECTURA);


print "FIN\n";

```

Y el correspondiente __Dockerfile__

```
FROM alpine:latest

# Establecemos el directorio de trabajo del ejercicio.
WORKDIR /Users/pp/Google\ Drive/mii/1/CC/pruebas/4

RUN apk update && apk add perl

ADD . /volumenGrandeFuera

# Copiamos el script hipepe a la raiz del contenedor
COPY ./hipepe.pl ./

# El comando a ejecutar es perl6 junto al script
CMD ["perl", "./hipepe.pl"]
```

Y creamos el nuevo contenedor (__alpineperlio__) con:


```shell
docker build --no-cache -t alpineperlio -f Dockerfile .
```

Lo ejecutamos con: 

```shell
docker run --mount source=unGranVolumen,destination=/volumenGrandeFuera alpineperlio
```


![Docker Build Run alpineperlio](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/05-docker-build-run-alipineperlio.png)

A continuación miramos las capas y la información de este contenedor con __dive__ y comprobamos que efectivamente el punto de montaje es el correcto, que es accesible desde fuera y que tiene permisos de escritura y lectura.

![Dive alpineperlio](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/05-docker-dive-alpineperlio.png)


# Ejercicio 6. Usar un miniframework REST para crear un servicio web y introducirlo en un contenedor, y componerlo con un cliente REST que sea el que finalmente se ejecuta y sirve como “frontend”.

Comenzamos la estructura creando el dockerfile de cada "proyecto". Por lo tanto tendremos un __Dockerfile__ para el servidor (el que contiene la api rest) y otro para el cliente (el que consume de esa api).

```shell
mkdir proyecto
cd proyecto
mkdir server client
touch server/Dockerfile client/Dockerfile
```

Y a crear el fichero de composición, para que cuando ejecutemos `docker-compose` sepa crear la respectiva composición de contenedores.

```
touch docker-componse.yml
```


# Ejercicio 7. Reproducir los contenedores creados anteriormente usando un `Dockerfile`.


# Ejercicio 8. Crear con docker-machine una máquina virtual local que permita desplegar contenedores y ejecutar en él contenedores creados con antelación.


# Referencias
* [Install docker OS X](https://medium.com/crowdbotics/a-complete-one-by-one-guide-to-install-docker-on-your-mac-os-using-homebrew-e818eb4cfc3)
* [Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
* [Dockerfile for Centos8 and Raku](https://github.com/nxadm/rakudo-pkg/blob/master/docker/Dockerfile-centos-x86_64-8)
* [Docker Commit](https://docs.docker.com/engine/reference/commandline/commit/)
* [Docker Layers](https://github.com/wagoodman/dive)