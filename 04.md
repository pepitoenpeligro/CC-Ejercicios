# Ejercicio 1. Realizar una aplicación básica que use `express` para devolver alguna estructura de datos del modelo que se viene usando en el curso.

Hemos inicializado un proyecto usando __npm__:

```
npm init -y
```

Posteriormente hemos inicializado el repositorio local con __git__:

```
git init
git add .
```

Instalamos el gestor de tareas:

```
npm install --save-dev gul
```

Añadimos las dependencias básicas de nuestro proyecto que son:
* __Body-parse__. Para facilitar el parseo de los datos en formato JSON.
* __dotenv__. Para gestionar variables de entorno de nuestro proyecto _.env_.
* __express__. El framework web que nos permite atender y resolver las peticiones HTTP.
* __nodemon__. Para recargar automáticamente las dependencias en ejecuciones de prueba, equivale a `watch`.
* __gulp_nodemon__. Para poder usar nodemon dentro de una tarea de `gulp`

Pasamos a construir nuestro microservicio mediante la definición de middlewares. En concreto hemos definido una ruta que responde `/api/songs` de forma general. No hemos especificado concrétamente a qué método HTTP. Ésto lo resolveremos en el siguiente ejercicio (Ejercicio 2) de una forma mucho más elegante que es creando un middleware para controlar las rutas y otro para realmente responder a cada peticion HTTP. En el caso del ejercicio 1, nos basta con introducirnos a `express`. El objeto a devolver es un array constante definido localmente con la información básica de tres canciones, las cuales incrustamos en el cuerpo de la respuesta `response`, indicando en la cabecera del paquete que la solicitud ha sido procesada correctamente `status(200)` y que el contenido que enviamos es de tipo `application/json`.


```javascript
const express = require("express");
const app = express();
const bodyParser = require('body-parser');
require('dotenv').config({path: __dirname + '/.env'});

app.use(bodyParser.json());

// Reemplazar use por get.
app.use('/api/songs', (request, response) => {
    
    let songs = [
        {
            title: 'Fever',
            album: 'Fever',
            artist: 'Dua Lipa & Angèle',
            duration: 157
        },
        {
            title:'7 rings',
            album:'thank u, next',
            artists: 'Ariana Grande',
            duration:179
        },
        {
            title:'Work Bit**',
            album:'Britney Jean (Deluxe Version)',
            artists: 'Britney Spears',
            duration:248
        }
    ];

    response.status(200);
    response.header("Content-Type",'application/json');
    response.send(
        JSON.stringify(songs, null, 3),
    );
})

const PORT = process.env.PORT || 3320;
app.listen(PORT, () => {
    console.log(`Microservice is running on port ${PORT}`);
});
```



```javascript
var gulp = require('gulp');

var nodemon = require('gulp-nodemon');

gulp.task('nodemon', function(){
    nodemon({
        script: 'index.js',
        ext: 'js'
    });
});
```

Iniciamos el microservicio con:

```bash
gulp nodemon
```

![gulp nodemon](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/01-gulp-nodemon.png)

Y realizamos las peticiones HTTP con __curl__.


Petición __GET__:

```bash
curl --location --request GET 'localhost:3320/api/songs' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain'
```
![curl get](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/01-curl.png)

Podemos comprobar la respuesta en el navegador:


![web](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/01-web.png)

:warning: Podemos encontrar una versión más avanzada de este microservicio en [MusicStoreNodejs](https://github.com/pepitoenpeligro/MusicStoreNodejs)


# Ejercicio 2. Programar un microservicio en express (o el lenguaje y marco elegido) que incluya variables como en el caso anterior.

Podemos encontrar el repositorio del microservicio en [MusicStoreNodejs](https://github.com/pepitoenpeligro/MusicStoreNodejs)

Hemos inicializado un proyecto usando __npm__:

```
npm init -y
```

Posteriormente hemos inicializado el repositorio local con __git__:

```
git init
git add .
```

Instalamos el gestor de tareas:

```
npm install --save-dev gul
```

Añadimos las dependencias básicas de nuestro proyecto que son:
* __Body-parse__. Para facilitar el parseo de los datos en formato JSON.
* __dotenv__. Para gestionar variables de entorno de nuestro proyecto _.env_.
* __express__. El framework web que nos permite atender y resolver las peticiones HTTP.
* __nodemon__. Para recargar automáticamente las dependencias en ejecuciones de prueba, equivale a `watch`.
* __gulp_nodemon__. Para poder usar nodemon dentro de una tarea de `gulp`
* __gulp_run__. Para poder establecer una tarea usando npm.

Y hemos establecido la siguiente estructura a nuestro proyecto:

```
├── LICENSE
├── README.md
├── controllers
├── gulpfile.js
├── index.js
├── node_modules
├── package-lock.json
├── package.json
└── routes
```

Donde controllers contiene los controladores de las peticiones, routes contiene la definición de las rutas y la vinculación con los métodos HTTP (POST y GET) que atendemos, `index.js` conteniendo la definición básica y `gulpfile.js` siendo nuestro gestor de tareas.



Definimos nuestro `index.js` como sigue a continuación:

```javascript
const express = require("express");
const app = express();
const bodyParser = require('body-parser');
const dataRoutes = require('./routes/songs');

require('dotenv').config({path: __dirname + '/.env'});


app.use(bodyParser.json());

app.use('/api', dataRoutes);

app.use(function(request, response){
    response.status(400);
    response.json({
        error:{
            'name': 'Error',
            'message': 'Our api is working just here: api/songs'
        }
    });
});

const PORT = process.env.PORT || 3320;
app.listen(PORT, () => {
    console.log(`Microservice is running on port ${PORT}`);
});
```


Cabe notar que la constate __PORT__ se encuentra definida en nuestro archivo de entorno __.env__. En caso de no encontrar dicho archivo se establecería a 3320. Si simplemente no se usa, como pasaría en un despliegue de la aplicación en __heroku__ que se asigna en el momento de despliegue, no ocurría nada y el puerto se establecería el que el proveedor estime oportuno.


Definimos nuestra vinculación `ruta-handler` en el archivo `routes/songs.js`.

```javascript
const express = require('express');
const router = express.Router();

const {getSongs, postSong} = require('../controllers/songController.js');

router.get('/songs', getSongs);
router.post('/song', postSong);

module.exports = router;
```


Quedando un único controlador `songController.js`

```
controllers
└── songController.js
```
que contiene las dos funciones que realmente responden a las peticiones:

```javascript
exports.getSongs = (request, response) => {
    var songs = [
        {
            title: 'Physical',
            album: 'Future Nostalgia',
            artist: 'Dua Lipa',
            duration: 194
        },
        {
            title:'Tom\'s Dinner',
            album:'Solitude Standing',
            artists: 'Suzanne Vega',
            duration:224
        }
    ];

    response.status(200);
    response.header("Content-Type",'application/json');
    response.send(JSON.stringify(songs, null, 3));
}

exports.postSong = (request, response) =>{
    response.status(200);
    response.send({
        song: request.body,
        message: 'Song POST ok'
    })
}
```

En el archivo `gulpfile.js` hemos definido dos tareas:

1. La primera para resetear el proceso cada vez que cambie algún archivo.
2. La segunda tarea para iniciar el servidor.

Quedando nuestro `gulpfile.js` como sigue:

```javascript
var gulp = require('gulp');

var nodemon = require('gulp-nodemon');
var run = require('gulp-run');

gulp.task('nodemon', function(){
    nodemon({
        script: 'index.js',
        ext: 'js'
    });
});

gulp.task('run', function(){
    return run('npm start').exec()
})
```

Por tanto para ejecutar nuestro microservicio solo nos es necesario ejecutar:

```bash
gulp run
```


![gulp run](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-gulp.png)

Vamos por tanto a probar el funcionamiento realizando peticiones. Vamos a comenzar con el navegador:


![home](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-web2.png)

Nos indica, acertadamente, que dicha ruta no es válida y que nuestro microservicio atiende mediante `/api/songs/`:


![/api/songs](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-web.png)


Ahora vamos a comprobar el funcionamiento con curl, para poder realizar una petición __POST__ (hubiera sido recomendable probar nuestro microservicio con __POSTMAN__).

Petición __GET__:

```bash
curl --location --request GET 'localhost:3320/api/songs' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain'
```

Petición __POST__: 

```bash
curl --location --request POST 'localhost:3320/api/song' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain' \
--data-raw '{
    "title": "Physical",
    "duration": 10
}'
```

Y podemos ver la respuesta:

![/api/songs](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-curl.png)

:warning: Fijémonos en el último middleware definido en el `index.js`. Contiene una definición de terminación amable mediante señales del sistema. Una parada abrupta del servidor puede dejar ese puerto en uso. Podemos comprobar los procesos en uso para un puerto concreto con la orden `sudo lsof -i :3320` y luego matar dicho proceso con  `kill -9 $PID`.

# Ejercicio 3. Crear pruebas para las diferentes rutas de la aplicación.

Comenzamos instalando `mocha` y `supertest`:

```bash
npm install --save -g mocha
npm install --save supertest
```

Y creamos un nuevo directorio llamado `test` dentro de la estructura de nuestro proyecto, quedando por tanto tal y como se muestra a continuación:

```
.
├── LICENSE
├── README.md
├── controllers
├── gulpfile.js
├── index.js
├── node_modules
├── package-lock.json
├── package.json
├── routes
└── test
```


Comenzamos añadiendo la implementación de los test funcionales en el archivo `test/songs.js`. Definimos un test para la petición __GET__ esperando en el cuerpo del mesaje HTTP un dato de tipo `json` y un código de respuesta 200 en la cabecera del paquete. Para la petición `POST` definimos una canción y al enviarla esperamos una respuesta de tipo `json` y un código de respuesta 200 en la cabecera del paquete HTTP.


La __API__ de __supertest__ permite establecer diferentes tipo de expectaciones ante la respuesta del servidor.

* __expect(status[, fn])__. Respondiendo al código de respuesta.
* __expect(status, body[, fn])__. Respondiendo al código de respuesta y al cuerpo del mensaje HTTP.
* __expect(body[, fn])__. Respondiendo al cuerpo del mensaje HTTP.
* __expect(field, value[, fn])__. Respondiendo a un campo concreto de un mensaje HTTP. Personalizable.
* __expect(function(res) {})__. Respondiendo a cualquier campo del mensaje HTTP. Permite definir aserciones personalizadas y si falla lanzará un errror. Es el que usaremos al ser el más potente y flexible.
* __end(fn)__. Permite definir una función callback para implementar aserciones a bajo nivel. No nos es necesario.


```javascript
require('dotenv').config({path: __dirname + '/.env'});
const PORT = process.env.PORT || 3320;
const app = require('../index.js');

const assert = require('assert');
var request = require('supertest');
var request = request(`http://localhost:${PORT}`);

const routeSongs = '/api/songs';
const routeSong = '/api/song';

describe('songs', ()=>{
    describe('GET', () => {
        it('It should return a songs list in json', (done) => {
            request.get(routeSongs)
                .expect('Content-Type', /json/)
                .expect(200, done);
        });
    });

    describe('POST', () => {
        it('It should accept a song in json', (done) =>{
            let song = {
                "title": "Physical",
                "album" : "Future Nostalgia",
                "artist" : "Dua Lipa",
                "duration": 10
            }

            request.post(routeSong)
                .send(song).
                expect('Content-Type', /json/)
                .expect(200, done);

        })
    })
});
```


Pasamos a ejecutar los test:

```
mocha test -s  0
```

Y obtenemos:

```
Microservice is running on port 3320


  songs
    GET
      ✓ It should return a songs list in json (39ms)
    POST
      ✓ It should accept a song in json (15ms)


  2 passing (61ms)

```



![mocha test](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/03-mocha.png)


# Ejercicio 4. Experimentar con diferentes gestores de procesos y servidores web front-end para un microservicio que se haya hecho con antelación, por ejemplo en la sección anterior.





# Ejercicio 5. Usar `rake`, `invoke` o la herramienta equivalente en tu lenguaje de programación para programar diferentes tareas que se puedan lanzar fácilmente desde la línea de órdenes.




# Referencias
* [mocha](https://www.npmjs.com/package/mocha)
* [supertest](https://www.google.com/search?client=safari&rls=en&q=supertest+npm&ie=UTF-8&oe=UTF-8)