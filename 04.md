# Ejercicio 1. Realizar una aplicación básica que use `express` para devolver alguna estructura de datos del modelo que se viene usando en el curso.


# Ejercicio 2. Programar un microservicio en express (o el lenguaje y marco elegido) que incluya variables como en el caso anterior.

Podemos encontrar el repositorio del microservicio en [MusicStoreNodejs](https://github.com/pepitoenpeligro/MusicStoreNodejs)

Hemos inicializado un proyecto usando __npm__:

```
npm init -y
```

Posteriormente hemos inicializado el repositorio local con __git__:

```
git init
git add .
```

Instalamos el gestor de tareas:

```
npm install --save-dev gul
```

Añadimos las dependencias básicas de nuestro proyecto que son:
* __Body-parse__. Para facilitar el parseo de los datos en formato JSON.
* __dotenv__. Para gestionar variables de entorno de nuestro proyecto _.env_.
* __express__. El framework web que nos permite atender y resolver las peticiones HTTP.
* __nodemon__. Para recargar automáticamente las dependencias en ejecuciones de prueba, equivale a `watch`.
* __gulp_nodemon__. Para poder usar nodemon dentro de una tarea de `gulp`
* __gulp_run__. Para poder establecer una tarea usando npm.

Y hemos establecido la siguiente estructura a nuestro proyecto:

```
├── LICENSE
├── README.md
├── controllers
├── gulpfile.js
├── index.js
├── node_modules
├── package-lock.json
├── package.json
└── routes
```

Donde controllers contiene los controladores de las peticiones, routes contiene la definición de las rutas y la vinculación con los métodos HTTP (POST y GET) que atendemos, `index.js` conteniendo la definición básica y `gulpfile.js` siendo nuestro gestor de tareas.



Definimos nuestro `index.js` como sigue a continuación:

```javascript
const express = require("express");
const app = express();
const bodyParser = require('body-parser');
const dataRoutes = require('./routes/songs');

require('dotenv').config({path: __dirname + '/.env'});


app.use(bodyParser.json());

app.use('/api', dataRoutes);

app.use(function(request, response){
    response.status(400);
    response.json({
        error:{
            'name': 'Error',
            'message': 'Our api is working just here: api/songs'
        }
    });
});

const PORT = process.env.PORT || 3320;
app.listen(PORT, () => {
    console.log(`Microservice is running on port ${PORT}`);
});
```


Cabe notar que la constate __PORT__ se encuentra definida en nuestro archivo de entorno __.env__. En caso de no encontrar dicho archivo se establecería a 3320. Si simplemente no se usa, como pasaría en un despliegue de la aplicación en __heroku__ que se asigna en el momento de despliegue, no ocurría nada y el puerto se establecería el que el proveedor estime oportuno.


Definimos nuestra vinculación `ruta-handler` en el archivo `routes/songs.js`.

```javascript
const express = require('express');
const router = express.Router();

const {getSongs, postSong} = require('../controllers/songController.js');

router.get('/songs', getSongs);
router.post('/song', postSong);

module.exports = router;
```


Quedando un único controlador `songController.js`

```
controllers
└── songController.js
```
que contiene las dos funciones que realmente responden a las peticiones:

```javascript
exports.getSongs = (request, response) => {
    var songs = [
        {
            title: 'Physical',
            album: 'Future Nostalgia',
            artist: 'Dua Lipa',
            duration: 194
        },
        {
            title:'Tom\'s Dinner',
            album:'Solitude Standing',
            artists: 'Suzanne Vega',
            duration:224
        }
    ];

    response.status(200);
    response.header("Content-Type",'application/json');
    response.send(JSON.stringify(songs, null, 3));
}

exports.postSong = (request, response) =>{
    response.status(200);
    response.send({
        song: request.body,
        message: 'Song POST ok'
    })
}
```

En el archivo `gulpfile.js` hemos definido dos tareas:

1. La primera para resetear el proceso cada vez que cambie algún archivo.
2. La segunda tarea para iniciar el servidor.

Quedando nuestro `gulpfile.js` como sigue:

```javascript
var gulp = require('gulp');

var nodemon = require('gulp-nodemon');
var run = require('gulp-run');

gulp.task('nodemon', function(){
    nodemon({
        script: 'index.js',
        ext: 'js'
    });
});

gulp.task('run', function(){
    return run('npm start').exec()
})
```

Por tanto para ejecutar nuestro microservicio solo nos es necesario ejecutar:

```bash
gulp run
```


![gulp run](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-gulp.png)

Vamos por tanto a probar el funcionamiento realizando peticiones. Vamos a comenzar con el navegador:


![home](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-web2.png)

Nos indica, acertadamente, que dicha ruta no es válida y que nuestro microservicio atiende mediante `/api/songs/`:


![/api/songs](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-web.png)


Ahora vamos a comprobar el funcionamiento con curl, para poder realizar una petición __POST__ (hubiera sido recomendable probar nuestro microservicio con __POSTMAN__).

Petición __GET__:

```bash
curl --location --request GET 'localhost:3320/api/songs' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain'
```

Petición __POST__: 

```bash
curl --location --request POST 'localhost:3320/api/song' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain' \
--data-raw '{
    "title": "Physical",
    "duration": 10
}'
```

Y podemos ver la respuesta:

![/api/songs](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/4/02-curl.png)



# Ejercicio 3. Crear pruebas para las diferentes rutas de la aplicación.


# Ejercicio 4. Experimentar con diferentes gestores de procesos y servidores web front-end para un microservicio que se haya hecho con antelación, por ejemplo en la sección anterior.


# Ejercicio 5. Usar `rake`, `invoke` o la herramienta equivalente en tu lenguaje de programación para programar diferentes tareas que se puedan lanzar fácilmente desde la línea de órdenes.




