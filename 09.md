# Composición de contenedores

`Crear un pod con dos o más contenedores, de forma que se pueda usar uno desde el otro. Uno de los contenedores contendrá la aplicación que queramos desplegar.`









`Usar un miniframework REST para crear un servicio web y introducirlo en un contenedor, y componerlo con un cliente REST que sea el que finalmente se ejecuta y sirve como “frontend”.`

Docker-compose es una herramienta que proporciona funcionalidades para poder orquestar contenedores de forma que los contenedores que yo defina en mi proyecto puedan interactuar entre ellos. La configuración de dicha orquestación debe estar explícita en el archivo `docker-compose.yml` en la raiz del directorio del proyecto.

Comenzamos la estructura creando el dockerfile de cada "proyecto". Por lo tanto tendremos un __Dockerfile__ para el servidor (el que contiene la api rest) y otro para el cliente (el que consume de esa api).

```shell
mkdir proyecto
cd proyecto
mkdir server client
touch server/Dockerfile client/Dockerfile
```

Y a crear el fichero de composición, para que cuando ejecutemos `docker-compose` sepa crear la respectiva composición de contenedores.

```shell
touch docker-componse.yml
```


A continuación, en server, vamos a crear una api rest en nodejs, por tanto:

```shell
npm init -y
touch index.js
```

Cambiamos el archivo `package.json` para añadir un nuevo script:

```javascript
"start": "node index.js"
```


Y añadimos al `server/index.js` el par <ruta,metodoHTTP> a la que express atiende:

```javascript
const express = require('express');
const app = express();
const cors = require('cors');

const PORT_LISTEN = 3000;

app.use(cors());

app.use(function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
    next();
  });

app.get('/', function(req, res) {
    const song1 = {
        title:'Physical',
        album:'Future Nostalgia',
        artists: ['Dua Lipa'],
        duration:194
    }

    const song2 = {
        title:'Tom\'s Diner',
        album:'Solitude Standing',
        artists: ['Suzanne Vega'],
        duration:224
    }
    res.json({songs:[song2, song1]});
});

app.listen(PORT_LISTEN, function(){
    console.log('Servidor escuchando en: ',PORT_LISTEN);
});
```

Estamos listos para montar este contendor y probar su funcionamiento:


```shell
docker build -t pepitoenpeligro/server .
docker run -p 3000:3000  pepitoenpeligro/server
```

:warning: Podemos usar la opción -d delante del nombre de la imagen para que se quede como demonio.


![Docker build and run server](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/06-docker-build-run-pepitoenpeligro-server.png)

Y comprobamos que efectivamente funciona:

![Docker build and run server - Check](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/06-pepitoenpeligro-server-ok.png)


Ahora vamos a pasar a construir el cliente.


```bash
npx create-react-app client
```

E instalamos una libreria adicional llamada `axios` para poder realizar peticiones al servidor:

```
npm install --save axios
```


Modificamos `package.json` para configurar el puerto de escucha del proyecto react:

```
"
scripts": {
    "start": "export PORT=4000 && react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "postinstall": "npm run build"
}
```


Modificamos el componente react principal `App.js` y introducimos la llamada al servidor:

```javascript
import React, { Component, useState, Fragment } from "react";
import axios from "axios";
import "./App.css";

const App = () => {
  const [values, setValues] = useState({
    songs: [],
  });

  const { songs } = values;

  React.useEffect(() => {
    setValues({ ...values });
    axios({
      method: "GET",
      url: `http://localhost:3000/`,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    })
      .then(function (response) {
        setValues((values) => ({
          ...values,
          songs: response.data.songs,
        }));
        console.log(response.data.songs);
      })
      .catch(function (error) {
        console.log(error);
      });
  }, []);

  return (
    <div>
      <h1>Music Store</h1>
      <table>
        <th>Title</th>
        <th>Album</th>
        <th>First Artist</th>
        <th>Duration (s)</th>
      {songs.map(row => (
        <tr key={row.id}>
          <td>{row.title}</td>
          <td>{row.album}</td>
          <td>{row.artists[0]}</td>
          <td>{row.duration}</td>
        </tr>
      ))}
      </table>
    </div>
  );
};

export default App;

```
Estamos listos para componer el contenedor. Rellenamos el `Dockerfile` del cliente:


```
FROM node:12.2.0-alpine

WORKDIR /Users/pp/Google\ Drive/mii/1/CC/pruebas/5/client

ENV PATH /app/node_modules/.bin:$PATH

COPY package*.json ./



RUN npm install 
RUN npm install react-scripts@3.0.1 -g

COPY . .

EXPOSE 4000

CMD ["npm", "start"]
```

Y estamos listos para construir y probar que este contenedor funciona:

```shell
docker build -t pepitoenpeligro/client .
docker run -p 4000:4000  pepitoenpeligro/client
```


![Docker Build Run and Client](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/06-pepito-client.png)


Estamos listos para configurar el fichero de orquestación `docker-compose.yml`.

```
version: '2'
services:
   server:
      container_name: server
      restart: always
      build: server/.
      ports:
      - "3000:3000"

   client:
      container_name: client
      build: client/.
      stdin_open: true
      ports:
      - "4000:4000"
```

Lanzamos la orquestación de los dos contenedores con:

```shell
docker-compose build up
```


Accedemos al puerto 4000 del cliente una vez lanzado los dos contenedores. En la línea de órdenes podemos observar como la información de cada contenedor está expuesto en un color diferente y así podemos realizar un seguimiento de la orquestación. Es destacable, aunque no necesario en este ejercicio, que se puede consultar los logs de cada contenedor por separado con la herramienta `docker-compose`

```
docker-compose logs --tail <contenedor>
```

![Docker Compose Up](https://github.com/pepitoenpeligro/CC-Ejercicios/blob/master/images/3/06-docker-compose-up.png)
